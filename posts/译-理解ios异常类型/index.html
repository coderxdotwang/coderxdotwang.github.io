<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>「译」理解iOS异常类型 | 编程蚂蚁</title><meta name=keywords content="iOS 异常"><meta name=description content="原文链接：Understanding iOS Exception Types (PS.由于未知原因已失效，经检查，文章中引用的链接都还有效 ：) 翻译：CoderWangx
 当你的iOS应用崩溃的时候，我们需要去分析异常日志以定位根本原因。崩溃可能是 “低内存崩溃 Low Memory Crash” 或者 “普通异常崩溃”。当碰到“异常”时，更好的理解“不同类型的异常”能够真正帮助我们快速定位问题所在。
在这篇文章中，我们将研究 iOS 应用可能碰到的不同类型的“异常”，例如EXC_CRASH、EXC_BAD_ACCESS、EXC_RESOURCE、00000020 等。
[TOC]
崩溃日志中的“异常” “异常”这个词在“崩溃日志”语境下更多与“Mach 异常”（以“EXC_为前缀”）和 “UNIX 信号”（如: SIGSEGV, SIGBUS等）相关。在某些情况下（应该是有对应的dSYM符号文件时）系统会通过映射将底层的 Mach 异常 翻译为 UNIX 信号。这就是为什么你能log中看到有用 “EXC_CRASH(SIGABRT)” 及 “EXC_BAC_ACCESS(SIGSEGV)” 作为 异常类型（Exception Type）。
对于某些异常，还会附带一个关联的 处理器定制异常码（processor-specific Exception Code） 或者 异常子类型（Exception Subtype），用以包含更多问题相关信息。举例来说， “EXC_BAC_ACCESS” 类型异常可能有一行如“KERN_INVALID_ADDRESS at 0x80000010”作为“异常码”； “EXC_RESOURCE” 可能有一行&#34;WAKEUPS&#34;作为&#34;异常子类别&#34;。
UNIX 信号 iOS开发者常见的 UNIX 信号 如下：
   UNIX 信号 注释     SIGSEGV 访问无效的内存地址。地址存在，但是应用程序无法访问。   SIGABRT 程序崩溃。由 C函数 abort() 初始化。通常意味着系统检测到某些事务出错，例如 assert() 或者 NSAssert() 校验失败。   SIGBUS 访问无效的内存地址。地址不存在，或对齐无效。（The address does not exist, or the alignment is invalid."><meta name=author content><link rel=canonical href=https://coderx.wang/posts/%E8%AF%91-%E7%90%86%E8%A7%A3ios%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B/><link crossorigin=anonymous href=/assets/css/stylesheet.min.ec8da366ca2fb647537ccb7a8f6fa5b4e9cd3c7a0d3171dd2d3baad1e49c8bfc.css integrity="sha256-7I2jZsovtkdTfMt6j2+ltOnNPHoNMXHdLTuq0eSci/w=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://coderx.wang/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://coderx.wang/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://coderx.wang/favicon-32x32.png><link rel=apple-touch-icon href=https://coderx.wang/apple-touch-icon.png><link rel=mask-icon href=https://coderx.wang/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="「译」理解iOS异常类型"><meta property="og:description" content="原文链接：Understanding iOS Exception Types (PS.由于未知原因已失效，经检查，文章中引用的链接都还有效 ：) 翻译：CoderWangx
 当你的iOS应用崩溃的时候，我们需要去分析异常日志以定位根本原因。崩溃可能是 “低内存崩溃 Low Memory Crash” 或者 “普通异常崩溃”。当碰到“异常”时，更好的理解“不同类型的异常”能够真正帮助我们快速定位问题所在。
在这篇文章中，我们将研究 iOS 应用可能碰到的不同类型的“异常”，例如EXC_CRASH、EXC_BAD_ACCESS、EXC_RESOURCE、00000020 等。
[TOC]
崩溃日志中的“异常” “异常”这个词在“崩溃日志”语境下更多与“Mach 异常”（以“EXC_为前缀”）和 “UNIX 信号”（如: SIGSEGV, SIGBUS等）相关。在某些情况下（应该是有对应的dSYM符号文件时）系统会通过映射将底层的 Mach 异常 翻译为 UNIX 信号。这就是为什么你能log中看到有用 “EXC_CRASH(SIGABRT)” 及 “EXC_BAC_ACCESS(SIGSEGV)” 作为 异常类型（Exception Type）。
对于某些异常，还会附带一个关联的 处理器定制异常码（processor-specific Exception Code） 或者 异常子类型（Exception Subtype），用以包含更多问题相关信息。举例来说， “EXC_BAC_ACCESS” 类型异常可能有一行如“KERN_INVALID_ADDRESS at 0x80000010”作为“异常码”； “EXC_RESOURCE” 可能有一行&#34;WAKEUPS&#34;作为&#34;异常子类别&#34;。
UNIX 信号 iOS开发者常见的 UNIX 信号 如下：
   UNIX 信号 注释     SIGSEGV 访问无效的内存地址。地址存在，但是应用程序无法访问。   SIGABRT 程序崩溃。由 C函数 abort() 初始化。通常意味着系统检测到某些事务出错，例如 assert() 或者 NSAssert() 校验失败。   SIGBUS 访问无效的内存地址。地址不存在，或对齐无效。（The address does not exist, or the alignment is invalid."><meta property="og:type" content="article"><meta property="og:url" content="https://coderx.wang/posts/%E8%AF%91-%E7%90%86%E8%A7%A3ios%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-06-16T17:47:50+08:00"><meta property="article:modified_time" content="2019-06-16T17:47:50+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="「译」理解iOS异常类型"><meta name=twitter:description content="原文链接：Understanding iOS Exception Types (PS.由于未知原因已失效，经检查，文章中引用的链接都还有效 ：) 翻译：CoderWangx
 当你的iOS应用崩溃的时候，我们需要去分析异常日志以定位根本原因。崩溃可能是 “低内存崩溃 Low Memory Crash” 或者 “普通异常崩溃”。当碰到“异常”时，更好的理解“不同类型的异常”能够真正帮助我们快速定位问题所在。
在这篇文章中，我们将研究 iOS 应用可能碰到的不同类型的“异常”，例如EXC_CRASH、EXC_BAD_ACCESS、EXC_RESOURCE、00000020 等。
[TOC]
崩溃日志中的“异常” “异常”这个词在“崩溃日志”语境下更多与“Mach 异常”（以“EXC_为前缀”）和 “UNIX 信号”（如: SIGSEGV, SIGBUS等）相关。在某些情况下（应该是有对应的dSYM符号文件时）系统会通过映射将底层的 Mach 异常 翻译为 UNIX 信号。这就是为什么你能log中看到有用 “EXC_CRASH(SIGABRT)” 及 “EXC_BAC_ACCESS(SIGSEGV)” 作为 异常类型（Exception Type）。
对于某些异常，还会附带一个关联的 处理器定制异常码（processor-specific Exception Code） 或者 异常子类型（Exception Subtype），用以包含更多问题相关信息。举例来说， “EXC_BAC_ACCESS” 类型异常可能有一行如“KERN_INVALID_ADDRESS at 0x80000010”作为“异常码”； “EXC_RESOURCE” 可能有一行&#34;WAKEUPS&#34;作为&#34;异常子类别&#34;。
UNIX 信号 iOS开发者常见的 UNIX 信号 如下：
   UNIX 信号 注释     SIGSEGV 访问无效的内存地址。地址存在，但是应用程序无法访问。   SIGABRT 程序崩溃。由 C函数 abort() 初始化。通常意味着系统检测到某些事务出错，例如 assert() 或者 NSAssert() 校验失败。   SIGBUS 访问无效的内存地址。地址不存在，或对齐无效。（The address does not exist, or the alignment is invalid."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://coderx.wang/posts/"},{"@type":"ListItem","position":2,"name":"「译」理解iOS异常类型","item":"https://coderx.wang/posts/%E8%AF%91-%E7%90%86%E8%A7%A3ios%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"「译」理解iOS异常类型","name":"「译」理解iOS异常类型","description":"原文链接：Understanding iOS Exception Types (PS.由于未知原因已失效，经检查，文章中引用的链接都还有效 ：) 翻译：CoderWangx\n 当你的iOS应用崩溃的时候，我们需要去分析异常日志以定位根本原因。崩溃可能是 “低内存崩溃 Low Memory Crash” 或者 “普通异常崩溃”。当碰到“异常”时，更好的理解“不同类型的异常”能够真正帮助我们快速定位问题所在。\n在这篇文章中，我们将研究 iOS 应用可能碰到的不同类型的“异常”，例如EXC_CRASH、EXC_BAD_ACCESS、EXC_RESOURCE、00000020 等。\n[TOC]\n崩溃日志中的“异常” “异常”这个词在“崩溃日志”语境下更多与“Mach 异常”（以“EXC_为前缀”）和 “UNIX 信号”（如: SIGSEGV, SIGBUS等）相关。在某些情况下（应该是有对应的dSYM符号文件时）系统会通过映射将底层的 Mach 异常 翻译为 UNIX 信号。这就是为什么你能log中看到有用 “EXC_CRASH(SIGABRT)” 及 “EXC_BAC_ACCESS(SIGSEGV)” 作为 异常类型（Exception Type）。\n对于某些异常，还会附带一个关联的 处理器定制异常码（processor-specific Exception Code） 或者 异常子类型（Exception Subtype），用以包含更多问题相关信息。举例来说， “EXC_BAC_ACCESS” 类型异常可能有一行如“KERN_INVALID_ADDRESS at 0x80000010”作为“异常码”； “EXC_RESOURCE” 可能有一行\u0026quot;WAKEUPS\u0026quot;作为\u0026quot;异常子类别\u0026quot;。\nUNIX 信号 iOS开发者常见的 UNIX 信号 如下：\n   UNIX 信号 注释     SIGSEGV 访问无效的内存地址。地址存在，但是应用程序无法访问。   SIGABRT 程序崩溃。由 C函数 abort() 初始化。通常意味着系统检测到某些事务出错，例如 assert() 或者 NSAssert() 校验失败。   SIGBUS 访问无效的内存地址。地址不存在，或对齐无效。（The address does not exist, or the alignment is invalid.","keywords":["iOS 异常"],"articleBody":" 原文链接：Understanding iOS Exception Types (PS.由于未知原因已失效，经检查，文章中引用的链接都还有效 ：) 翻译：CoderWangx\n 当你的iOS应用崩溃的时候，我们需要去分析异常日志以定位根本原因。崩溃可能是 “低内存崩溃 Low Memory Crash” 或者 “普通异常崩溃”。当碰到“异常”时，更好的理解“不同类型的异常”能够真正帮助我们快速定位问题所在。\n在这篇文章中，我们将研究 iOS 应用可能碰到的不同类型的“异常”，例如EXC_CRASH、EXC_BAD_ACCESS、EXC_RESOURCE、00000020 等。\n[TOC]\n崩溃日志中的“异常” “异常”这个词在“崩溃日志”语境下更多与“Mach 异常”（以“EXC_为前缀”）和 “UNIX 信号”（如: SIGSEGV, SIGBUS等）相关。在某些情况下（应该是有对应的dSYM符号文件时）系统会通过映射将底层的 Mach 异常 翻译为 UNIX 信号。这就是为什么你能log中看到有用 “EXC_CRASH(SIGABRT)” 及 “EXC_BAC_ACCESS(SIGSEGV)” 作为 异常类型（Exception Type）。\n对于某些异常，还会附带一个关联的 处理器定制异常码（processor-specific Exception Code） 或者 异常子类型（Exception Subtype），用以包含更多问题相关信息。举例来说， “EXC_BAC_ACCESS” 类型异常可能有一行如“KERN_INVALID_ADDRESS at 0x80000010”作为“异常码”； “EXC_RESOURCE” 可能有一行\"WAKEUPS\"作为\"异常子类别\"。\nUNIX 信号 iOS开发者常见的 UNIX 信号 如下：\n   UNIX 信号 注释     SIGSEGV 访问无效的内存地址。地址存在，但是应用程序无法访问。   SIGABRT 程序崩溃。由 C函数 abort() 初始化。通常意味着系统检测到某些事务出错，例如 assert() 或者 NSAssert() 校验失败。   SIGBUS 访问无效的内存地址。地址不存在，或对齐无效。（The address does not exist, or the alignment is invalid.）   SIGTRAP 调试器相关   SIGILL 尝试执行非法的、有缺陷、未知的或者需要权限的指令。     更多 UNIX 信号 可以参考这里：Unix_signal。\n Mach 异常    Mach 异常 描述 注释     EXC_BAD_ACCESS 错误内存访问 访问“错误”内存地址。“错误”可能指“地址不存在”或者“应用没有权限访问”。因此通常与 SIGBUS 及 SIGSEGV 相关联。   EXC_CRASH 异常跳出 通常与 SIGABRT 相关联，意思是由于检测到代码抛出的未捕获异常而使应用程序异常退出。   EXC_BREAKPOINT 跟踪/断点捕获 通用与 SIGTRAP 相关联。可以由你自己的代码或者 NSExceptions 抛出时触发。   EXC_GUARD 违反了受保护资源的防护（Violated Guarded Resource Protection） 由违背受保护资源防护触发，例如‘某些文件描述符’。   EXC_BAD_INSTRUCTION 非法指令 通常与特定非法或未定义指令/操作数相关。   EXC_RESOURCE 资源限制 应用由于达到资源消耗限制而退出。   00000020 十六进制异常类型 非 ‘OS Kernel’ 异常。     查看完整 Mach 异常列表请参考 这里 (sys/osfmk/mach/exception_types.h )的源码文件。\n 异常 EXC_BAD_ACCESS（错误内存访问） “EXC_BAD_ACCESS” 是APP崩溃时最常见的异常之一。不幸的是，调试起来却不容易。\n一般有两种可能性：\n 访问某些尚未初始化的对象。(SIGBUS) 访问已经被 ARC 释放（导致地址变为不可访问）的对象。如果是这个情况，你通常可以在崩溃日志中的 “Backtrace” 顶部附近看到 objc_release。  示例如：\nException Type: EXC_BAD_ACCESS (SIGSEGV) Exception Codes: KERN_INVALID_ADDRESS at 0x6d783f44 ... Exception Type: EXC_BAD_ACCESS (SIGBUS) Exception Codes: KERN_PROTECTION_FAILURE at 0x00000011 “EXC_BAD_ACCESS”也有关联的“异常码”以帮助提供额外信息。举例来说，KERN_PROTECTION_FAILURE 表示内存有效，但是不允许当前形式的访问，KERN_INVALID_ADDRESS 意思是地址当前无效。\n 查看这里的源码文件获取完整的可能值列表。\n 为了辅助调试 “EXC_BAD_ACCESS” 类型异常，你可以勾选 Xcode 中的 “Enable Zombie Objects” 后再尝试。\nEXC_CRASH（异常跳出） 相较于 “EXC_BAD_ACCESS”，“EXC_CRASH\" 更容易遇到。它通常发生在对象接收到未实现的消息时，如 Xcode 调试器中显示的 “unrecognized selector sent to instance 0x6a33840”。\n 一般情况里这个异常会与调试器一起发挥作用，因为调试器可以中断进程。如果没有附加调试器，会生成一个崩溃日志。\n 崩溃日志中展示的信息示例：\nException Type: EXC_CRASH (SIGABRT) Exception Codes: 0x0000000000000000, 0x0000000000000000 ... ## Usually you will see a similar line in the \"backtrace\" part 2 CoreFoundation 0x36c02e02 -[NSObject(NSObject) doesNotRecognizeSelector:] + 166  可能存在某些与“unrecognized selector”无关的特殊情况。如果碰到了，请注意到处都有可能发生这种事情。\n 另一个常见的“EXC_CRASH”情况是关于“应用扩展（App Extensions）”。应用扩展如果“花了太长时间来初始化”则会被系统终止。在这种情况下，异常子类型（Exception Subtype）显示为 LAUNCH_HANG，附带一个得体的异常消息（Exception Message）：\nException Type: EXC_CRASH (SIGABRT) Exception Subtype: LAUNCH_HANG Exception Message: The extension took too much time to initialize EXC_BREAKPOINT（跟踪捕获） 与“EXC_CRASH”非常相似，EXC_BREAKPOINT 也往往与调试器一起发挥作用，在测试阶段被捕获。 当使用 Swift 时，在以下情况这个异常会在运行时抛出：\n 一个非可选类型值为nil 强制类型转换失败  示例信息如：\nException Type: EXC_BREAKPOINT (SIGTRAP) Exception Codes: 0x0000000000000002, 0x0000000000000000  你可以在代码中手动调用 __builtin_trap() 来触发这个异常。\n EXC_GUARD（违反了受保护资源的防护） 与其他所有“EXC_”前缀的异常不同，这个异常不是一个“原生”的 Mach 异常。事实上，它是为 XNU - 一个苹果开发的衍生操作系统内核 而添加的。\n “XNU” 代表 “X 不是 Unix”（X is Not Unix）。 “EXC_GUARD”的定义可以在这里-osfmk/mach/exception_types.h 找到。\n 这个异常的一个较好例子是应用程序在 Core Data 访问 SQLite 文件时关闭了它的“文件描述符（file descriptor）”。\n在 iOS7 之前，这个异常会附带一部分“异常码（Exception Codes）”以帮助理解情况。异常码包含“两个”位域代码（如：0x400000010000005e）及subcode（如：0x00007f8254a019c0）。\n位域代码部分可分解为“3”个区：\n Guard Type - 这个时候只有一种类型 - 受保护的文件描述符（guarded file descriptor（GUARD_TYPE_FD））。值为0x2。如果你看到时 0x4 作为代码的前缀，则这个崩溃与“文件描述符”相关。 Flavor - 当违反“受保护的文件描述符”时的不同条件： 如果设置了“第1”（[32]: \"1 ）位（kGUARD_EXC_CLOSE），则它曾试图在“受保护的文件描述”上调用 close()。 如果设置了“第2”（[33]: \"1 ）位（kGUARD_EXC_DUP），则它试图在“受保护的文件描述符”上使用 F_DUPFD 或 F_DUPFD_CLOEXEC 调用 dup(2),dup2(2),fcntl(2)。还包含了尝试使用 /dev/fd/打开“文件描述符”。 如果设置了“第3”（[34]: \"1 ）位（kGUARD_EXC_NOCLOEXEC），则它试图关闭“文件描述符”上的“close-on-exec”标志。 如果设置了“第4”（[35]: \"1 ）位（kGUARD_EXC_SOCKET_IPC），则它试图通过 套接字（socket）发送“受保护的文件描述符”。 如果设置了“第5”（[36]: \"1 ）位（GUARD_FILEPORT），则它曾试图通过 套接字（socket）从“受保护的文件描述符”创建一个文件端口。 如果设置了“第6”（[37]: \"1 ）位（kGUARD_EXC_MISMATCH），说明“受保护的文件描述符”与“守卫”不相符。 如果设置了“第7”（[38]: ）位（kGUARD_EXC_WRITE），则它曾试图通过 套接字（socket）写入一个“受保护的文件描述符”。 File Descriptor - 应用尝试操作的受保护的文件描述符。- subcode部分包含“受保护的值”。   详细定义可以在这里（/bsd/sys/guarded.h ）找到。\n 从 iOS 7 开始，“Exception Codes”被提供更详细解释的“Exception Subtype”和“Exception Message”替代。\n# iOS 6 Exception Type: EXC_GUARD Exception Codes: 0x400000010000005e, 0x00007f8254a019c0 # The type is \"GUARD_TYPE_FD\" (0x4), with \"kGUARD_EXC_CLOSE\". The FD is \"94\". # ------- # iOS 7 and above Exception Type: EXC_GUARD Exception Subtype: GUARD_TYPE_FD Exception Message: CLOSE on file descriptor 81 (guarded with 0x0000000017e6eed0) EXC_BAD_INSTRUCTION（非法指令） “EXC_BAD_INSTRUCTION”，通常与“SIGILL”关联，是一个非常容易理解的异常 - 即你正在使用“错误”的指令或操作。然而，有时候也很难去调试。\n以下是一些较常见的情况。 由于Xcode提供的调试信息，这个很容易识别 - 它是由于不安全的解包导致的。\n## Usually show \"EXC_BAD_INSTRUCTION (code=EXC_I386_INVOP, subcode=0x0)\" in Xcode. “fatal error: unexpectedly found nil while unwrapping an Optional value” 但是，像这样和这样（均为StackOverflow上的问题）的就不容易了 - 第一个是有关于 GCD 的使用，另一个是苹果的bug。 以下是崩溃日志中的显示格式：\nException Type: EXC_BAD_INSTRUCTION (SIGILL) Exception Codes: 0x0000000000000001, 0x000000000000b6d2 EXC_RESOURCE “EXC_RESOURCE”意思是进程“达到资源消耗上限”。通常，当你的应用在一定时间内持续超出限制时会被触发。 这个异常包含“Exception Subtype”以帮助理解实际情况：\n CPU - 限制为 50%，时间不超过 180秒。 WAKEUPS - 表示线程每秒唤醒次数太多。限制为 150次/每秒， 时间不超过 300秒。 MEMORY - 没有相关文档描述限制信息。  与“EXC_GUARD”类似，它曾使用“位域”来传递信息，现在也使用“Exception SubType”和“Exception Message”。\nException Type: EXC_RESOURCE Exception Subtype: CPU Exception Message: (Limit 50%) Observed 85% over 180 secs --- Exception Type: EXC_RESOURCE Exception Subtype: WAKEUPS Exception Message: (Limit 150/sec) Observed 206/sec over 300 secs --- Exception Type: EXC_RESOURCE Exception Subtype: MEMORY Exception Message: Crossed High Water Mark 00000020 与“EXC_”异常不同，这个“异常类型”实际上不能告诉你任何信息。取而代之，你应该查看“异常代码”获取更多详情。\n 0x8badf00d（读作 ate bad food）- 表示由于 watchdog 出现超时而导致应用被操作系统终止。通常意味着应用程序花了太长时间启动、关闭或者响应系统事件。一个非常典型的情况是“在主线程上做同步网络请求”。 0xbaaaaaad（读作 “plooookhy”）- 表示日志是整个系统的堆栈，而不是崩溃报告。 0xc00010ff（读作 cool off（冷静））- 表示应用程序被系统关闭以响应热事件。 0xbad22222 - 表示操作系统终止了一个VoIP程序，因为它过于频繁的执行恢复。 0xdead10cc（读作 dead lock（死锁））- 表示应用在后台运行时保持了系统资源。 0xdeadfa11（读作 deadfall）- 表示应用被用户强制关闭了。强制关闭发生于用户先按下电源键直到“滑动来关机”出现然后按住主屏幕按钮。   这些“十六进制”代码实际上是六音词 - 由我们开发者创建作为不容易忘记的魔法数字。\n 扩展阅读 你可查看这篇文章 Demystifying iOS Application Crash Logs  以了解iOS异常日志结构。\n","wordCount":"550","inLanguage":"en","datePublished":"2019-06-16T17:47:50+08:00","dateModified":"2019-06-16T17:47:50+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://coderx.wang/posts/%E8%AF%91-%E7%90%86%E8%A7%A3ios%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B/"},"publisher":{"@type":"Organization","name":"编程蚂蚁","logo":{"@type":"ImageObject","url":"https://coderx.wang/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://coderx.wang/ accesskey=h title="编程蚂蚁 (Alt + H)">编程蚂蚁</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>「译」理解iOS异常类型</h1><div class=post-meta><span title="2019-06-16 17:47:50 +0800 +0800">June 16, 2019</span></div></header><div class=post-content><blockquote><p>原文链接：<a href=http://www.5neo.be/understanding-ios-exception-types/>Understanding iOS Exception Types</a> (PS.由于未知原因已失效，经检查，文章中引用的链接都还有效 ：)
翻译：CoderWangx</p></blockquote><p>当你的iOS应用崩溃的时候，我们需要去分析<strong>异常日志</strong>以定位根本原因。崩溃可能是 “低内存崩溃 <a href=https://developer.apple.com/library/ios/technotes/tn2151/_index.html>Low Memory Crash</a>” 或者 “普通异常崩溃”。当碰到“异常”时，更好的理解“不同类型的异常”能够真正帮助我们快速定位问题所在。</p><p>在这篇文章中，我们将研究 iOS 应用可能碰到的不同类型的“异常”，例如<strong>EXC_CRASH</strong>、<strong>EXC_BAD_ACCESS</strong>、<strong>EXC_RESOURCE</strong>、<strong>00000020</strong> 等。</p><p>[TOC]</p><h3 id=崩溃日志中的异常>崩溃日志中的“异常”<a hidden class=anchor aria-hidden=true href=#崩溃日志中的异常>#</a></h3><p>“异常”这个词在“崩溃日志”语境下更多与“Mach 异常”（以“<strong>EXC_<strong>为前缀”）和 “</strong><a href=https://en.wikipedia.org/wiki/Unix_signal>UNIX 信号</a></strong>”（如: <strong>SIGSEGV</strong>, <strong>SIGBUS</strong>等）相关。在某些情况下（应该是有对应的dSYM符号文件时）系统会通过映射将底层的 <strong>Mach 异常</strong> 翻译为 <strong>UNIX 信号</strong>。这就是为什么你能log中看到有用 <strong>“EXC_CRASH(SIGABRT)”</strong> 及 <strong>“EXC_BAC_ACCESS(SIGSEGV)”</strong> 作为 <strong><code>异常类型（Exception Type）</code></strong>。</p><p>对于某些异常，还会附带一个关联的 <strong>处理器定制异常码（processor-specific Exception Code）</strong> 或者 <strong>异常子类型（Exception Subtype）</strong>，用以包含更多问题相关信息。举例来说， <strong>“EXC_BAC_ACCESS”</strong> 类型异常可能有一行如“KERN_INVALID_ADDRESS at 0x80000010”作为“异常码”； <strong>“EXC_RESOURCE”</strong> 可能有一行"WAKEUPS"作为"异常子类别"。</p><h3 id=unix-信号>UNIX 信号<a hidden class=anchor aria-hidden=true href=#unix-信号>#</a></h3><p>iOS开发者常见的 UNIX 信号 如下：</p><table><thead><tr><th style=text-align:left>UNIX 信号</th><th style=text-align:left>注释</th></tr></thead><tbody><tr><td style=text-align:left><a href=http://en.wikipedia.org/wiki/SIGSEGV>SIGSEGV</a></td><td style=text-align:left>访问无效的内存地址。地址存在，但是应用程序无法访问。</td></tr><tr><td style=text-align:left><a href=http://en.wikipedia.org/wiki/SIGABRT>SIGABRT</a></td><td style=text-align:left>程序崩溃。由 C函数 <code>abort()</code> 初始化。通常意味着系统检测到某些事务出错，例如 <code>assert()</code> 或者 <code>NSAssert()</code> 校验失败。</td></tr><tr><td style=text-align:left><a href=http://en.wikipedia.org/wiki/SIGBUS>SIGBUS</a></td><td style=text-align:left>访问无效的内存地址。地址不存在，或对齐无效。（The address does not exist, or the alignment is invalid.）</td></tr><tr><td style=text-align:left><a href=http://en.wikipedia.org/wiki/SIGTRAP>SIGTRAP</a></td><td style=text-align:left>调试器相关</td></tr><tr><td style=text-align:left><a href=http://en.wikipedia.org/wiki/SIGILL>SIGILL</a></td><td style=text-align:left>尝试执行非法的、有缺陷、未知的或者需要权限的指令。</td></tr></tbody></table><blockquote><p>更多 UNIX 信号 可以参考这里：<a href=https://en.wikipedia.org/wiki/Unix_signal>Unix_signal</a>。</p></blockquote><h3 id=mach-异常>Mach 异常<a hidden class=anchor aria-hidden=true href=#mach-异常>#</a></h3><table><thead><tr><th style=text-align:left>Mach 异常</th><th style=text-align:left>描述</th><th style=text-align:left>注释</th></tr></thead><tbody><tr><td style=text-align:left>EXC_BAD_ACCESS</td><td style=text-align:left>错误内存访问</td><td style=text-align:left>访问“错误”内存地址。“错误”可能指“地址不存在”或者“应用没有权限访问”。因此通常与 <strong>SIGBUS</strong> 及 <strong>SIGSEGV</strong> 相关联。</td></tr><tr><td style=text-align:left>EXC_CRASH</td><td style=text-align:left>异常跳出</td><td style=text-align:left>通常与 <strong>SIGABRT</strong> 相关联，意思是由于检测到代码抛出的未捕获异常而使应用程序异常退出。</td></tr><tr><td style=text-align:left>EXC_BREAKPOINT</td><td style=text-align:left>跟踪/断点捕获</td><td style=text-align:left>通用与 <strong>SIGTRAP</strong> 相关联。可以由你自己的代码或者 NSExceptions 抛出时触发。</td></tr><tr><td style=text-align:left>EXC_GUARD</td><td style=text-align:left>违反了受保护资源的防护（Violated Guarded Resource Protection）</td><td style=text-align:left>由违背受保护资源防护触发，例如‘某些文件描述符’。</td></tr><tr><td style=text-align:left>EXC_BAD_INSTRUCTION</td><td style=text-align:left>非法指令</td><td style=text-align:left>通常与特定非法或未定义指令/操作数相关。</td></tr><tr><td style=text-align:left>EXC_RESOURCE</td><td style=text-align:left>资源限制</td><td style=text-align:left>应用由于达到资源消耗限制而退出。</td></tr><tr><td style=text-align:left>00000020</td><td style=text-align:left>十六进制异常类型</td><td style=text-align:left>非 &lsquo;OS Kernel&rsquo; 异常。</td></tr></tbody></table><blockquote><p>查看完整 Mach 异常列表请参考 <a href="http://fxr.watson.org/fxr/source/osfmk/mach/exception_types.h?v=xnu-2050.18.24">这里</a> (<code>sys/osfmk/mach/exception_types.h </code>)的源码文件。</p></blockquote><h3 id=异常>异常<a hidden class=anchor aria-hidden=true href=#异常>#</a></h3><h4 id=exc_bad_access错误内存访问>EXC_BAD_ACCESS（错误内存访问）<a hidden class=anchor aria-hidden=true href=#exc_bad_access错误内存访问>#</a></h4><p>“EXC_BAD_ACCESS” 是APP崩溃时最常见的异常之一。不幸的是，调试起来却不容易。</p><p>一般有两种可能性：</p><ul><li>访问某些尚未初始化的对象。(<strong>SIGBUS</strong>)</li><li>访问已经被 ARC 释放（导致地址变为不可访问）的对象。如果是这个情况，你通常可以在崩溃日志中的 “Backtrace” 顶部附近看到 <code>objc_release</code>。</li></ul><p>示例如：</p><pre tabindex=0><code>Exception Type: EXC_BAD_ACCESS (SIGSEGV)
Exception Codes: KERN_INVALID_ADDRESS at 0x6d783f44
...
Exception Type: EXC_BAD_ACCESS (SIGBUS)
Exception Codes: KERN_PROTECTION_FAILURE at 0x00000011
</code></pre><p>“EXC_BAD_ACCESS”也有关联的“异常码”以帮助提供额外信息。举例来说，<code>KERN_PROTECTION_FAILURE</code> 表示内存有效，但是不允许当前形式的访问，<code>KERN_INVALID_ADDRESS</code> 意思是地址当前无效。</p><blockquote><p>查看<a href="http://fxr.watson.org/fxr/source/osfmk/mach/kern_return.h?v=xnu-2050.18.24">这里</a>的源码文件获取完整的可能值列表。</p></blockquote><p>为了辅助调试 “EXC_BAD_ACCESS” 类型异常，你可以勾选 Xcode 中的 “Enable Zombie Objects” 后再尝试。</p><h4 id=exc_crash异常跳出>EXC_CRASH（异常跳出）<a hidden class=anchor aria-hidden=true href=#exc_crash异常跳出>#</a></h4><p>相较于 “EXC_BAD_ACCESS”，“EXC_CRASH" 更容易遇到。它通常发生在对象接收到未实现的消息时，如 Xcode 调试器中显示的 “unrecognized selector sent to instance 0x6a33840”。</p><blockquote><p>一般情况里这个异常会与调试器一起发挥作用，因为调试器可以中断进程。如果没有附加调试器，会生成一个崩溃日志。</p></blockquote><p>崩溃日志中展示的信息示例：</p><pre tabindex=0><code>Exception Type: EXC_CRASH (SIGABRT)
Exception Codes: 0x0000000000000000, 0x0000000000000000
...
## Usually you will see a similar line in the &#34;backtrace&#34; part
2 CoreFoundation 0x36c02e02 -[NSObject(NSObject) doesNotRecognizeSelector:] + 166
</code></pre><blockquote><p>可能存在某些与“unrecognized selector”无关的特殊情况。如果碰到了，请注意到处都有可能发生这种事情。</p></blockquote><p>另一个常见的“EXC_CRASH”情况是关于“应用扩展（App Extensions）”。应用扩展如果“花了太长时间来初始化”则会被系统终止。在这种情况下，<strong>异常子类型（Exception Subtype）<strong>显示为 <code>LAUNCH_HANG</code>，附带一个得体的</strong>异常消息（Exception Message）</strong>：</p><pre tabindex=0><code>Exception Type: EXC_CRASH (SIGABRT)
Exception Subtype: LAUNCH_HANG
Exception Message: The extension took too much time to initialize
</code></pre><h4 id=exc_breakpoint跟踪捕获>EXC_BREAKPOINT（跟踪捕获）<a hidden class=anchor aria-hidden=true href=#exc_breakpoint跟踪捕获>#</a></h4><p>与“EXC_CRASH”非常相似，<strong>EXC_BREAKPOINT</strong> 也往往与调试器一起发挥作用，在测试阶段被捕获。
当使用 <strong>Swift</strong> 时，在以下情况这个异常会在运行时抛出：</p><ul><li>一个非可选类型值为nil</li><li>强制类型转换失败</li></ul><p>示例信息如：</p><pre tabindex=0><code>Exception Type: EXC_BREAKPOINT (SIGTRAP)
Exception Codes: 0x0000000000000002, 0x0000000000000000
</code></pre><blockquote><p>你可以在代码中手动调用 <code>__builtin_trap()</code> 来触发这个异常。</p></blockquote><h4 id=exc_guard违反了受保护资源的防护>EXC_GUARD（违反了受保护资源的防护）<a hidden class=anchor aria-hidden=true href=#exc_guard违反了受保护资源的防护>#</a></h4><p>与其他所有“EXC_”前缀的异常不同，这个异常不是一个“原生”的 Mach 异常。事实上，它是为 <strong><a href=https://en.wikipedia.org/wiki/XNU>XNU</a></strong> - 一个苹果开发的衍生操作系统内核 而添加的。</p><blockquote><p>&ldquo;<strong>XNU</strong>&rdquo; 代表 &ldquo;X 不是 Unix&rdquo;（X is Not Unix）。
“EXC_GUARD”的定义可以在<a href=http://www.opensource.apple.com/source/xnu/xnu-2422.1.72/osfmk/mach/exception_types.h>这里</a>-<code>osfmk/mach/exception_types.h </code>找到。</p></blockquote><p>这个异常的一个较好例子是应用程序在 Core Data 访问 SQLite 文件时关闭了它的“文件描述符（file descriptor）”。</p><p>在 iOS7 之前，这个异常会附带一部分“异常码（Exception Codes）”以帮助理解情况。异常码包含“两个”位域代码（如：<code>0x400000010000005e</code>）及<strong>subcode</strong>（如：<code>0x00007f8254a019c0</code>）。</p><p>位域代码部分可分解为“3”个区：</p><ul><li><strong>Guard Type</strong> - 这个时候只有一种类型 - <strong>受保护的文件描述符（guarded file descriptor（GUARD_TYPE_FD））</strong>。值为<code>0x2</code>。如果你看到时 <strong>0x4</strong> 作为代码的前缀，则这个崩溃与“文件描述符”相关。</li><li><strong>Flavor</strong> - 当违反“受保护的文件描述符”时的不同条件：
如果设置了“第1”（<code>[32]: "1 &lt;&lt; 0"</code>）位（<strong>kGUARD_EXC_CLOSE</strong>），则它曾试图在“受保护的文件描述”上调用 <code>close()</code>。
如果设置了“第2”（<code>[33]: "1 &lt;&lt; 1"</code>）位（<strong>kGUARD_EXC_DUP</strong>），则它试图在“受保护的文件描述符”上使用 <code>F_DUPFD</code> 或 <code>F_DUPFD_CLOEXEC</code> 调用 <code>dup(2)</code>,<code>dup2(2)</code>,<code>fcntl(2)</code>。还包含了尝试使用 <code>/dev/fd/</code>打开“文件描述符”。
如果设置了“第3”（<code>[34]: "1 &lt;&lt; 2"</code>）位（<strong>kGUARD_EXC_NOCLOEXEC</strong>），则它试图关闭“文件描述符”上的“close-on-exec”标志。
如果设置了“第4”（<code>[35]: "1 &lt;&lt; 3"</code>）位（<strong>kGUARD_EXC_SOCKET_IPC</strong>），则它试图通过 套接字（socket）发送“受保护的文件描述符”。
如果设置了“第5”（<code>[36]: "1 &lt;&lt; 4"</code>）位（<strong>GUARD_FILEPORT</strong>），则它曾试图通过 套接字（socket）从“受保护的文件描述符”创建一个文件端口。
如果设置了“第6”（<code>[37]: "1 &lt;&lt; 5"</code>）位（<strong>kGUARD_EXC_MISMATCH</strong>），说明“受保护的文件描述符”与“守卫”不相符。
如果设置了“第7”（<code>[38]: &lt;&lt; 6</code>）位（<strong>kGUARD_EXC_WRITE</strong>），则它曾试图通过 套接字（socket）写入一个“受保护的文件描述符”。</li><li><strong>File Descriptor</strong> - 应用尝试操作的受保护的文件描述符。- <strong>subcode</strong>部分包含“受保护的值”。</li></ul><blockquote><p>详细定义可以在<a href=http://www.opensource.apple.com/source/xnu/xnu-2782.10.72/bsd/sys/guarded.h>这里</a>（<code>/bsd/sys/guarded.h </code>）找到。</p></blockquote><p>从 iOS 7 开始，“Exception Codes”被提供更详细解释的“Exception Subtype”和“Exception Message”替代。</p><pre tabindex=0><code># iOS 6
Exception Type: EXC_GUARD
Exception Codes: 0x400000010000005e, 0x00007f8254a019c0
# The type is &#34;GUARD_TYPE_FD&#34; (0x4), with &#34;kGUARD_EXC_CLOSE&#34;. The FD is &#34;94&#34;.
# -------
# iOS 7 and above
Exception Type: EXC_GUARD
Exception Subtype: GUARD_TYPE_FD
Exception Message: CLOSE on file descriptor 81 (guarded with 0x0000000017e6eed0)
</code></pre><h4 id=exc_bad_instruction非法指令>EXC_BAD_INSTRUCTION（非法指令）<a hidden class=anchor aria-hidden=true href=#exc_bad_instruction非法指令>#</a></h4><p>“EXC_BAD_INSTRUCTION”，通常与“<strong>SIGILL</strong>”关联，是一个非常容易理解的异常 - 即你正在使用“错误”的指令或操作。然而，有时候也很难去调试。</p><p>以下是一些较常见的情况。
由于Xcode提供的调试信息，这个很容易识别 - 它是由于不安全的解包导致的。</p><pre tabindex=0><code>## Usually show &#34;EXC_BAD_INSTRUCTION (code=EXC_I386_INVOP, subcode=0x0)&#34; in Xcode.
“fatal error: unexpectedly found nil while unwrapping an Optional value”
</code></pre><p>但是，像<a href=http://stackoverflow.com/questions/24337791/exc-bad-instruction-code-exc-i386-invop-subcode-0x0-on-dispatch-semaphore-dis>这样</a>和<a href=http://stackoverflow.com/questions/2506302/exc-bad-instruction-sigill-at-random-during-use-of-app-bug-in-appkit>这样</a>（均为StackOverflow上的问题）的就不容易了 - 第一个是有关于 GCD 的使用，另一个是苹果的bug。
以下是崩溃日志中的显示格式：</p><pre tabindex=0><code>Exception Type: EXC_BAD_INSTRUCTION (SIGILL)
Exception Codes: 0x0000000000000001, 0x000000000000b6d2
</code></pre><h4 id=exc_resource>EXC_RESOURCE<a hidden class=anchor aria-hidden=true href=#exc_resource>#</a></h4><p>“EXC_RESOURCE”意思是进程“达到资源消耗上限”。通常，当你的应用在一定时间内持续超出限制时会被触发。
这个异常包含“<strong>Exception Subtype</strong>”以帮助理解实际情况：</p><ul><li><strong>CPU</strong> - 限制为 <code>50%</code>，时间不超过 <code>180秒</code>。</li><li><strong>WAKEUPS</strong> - 表示线程每秒唤醒次数太多。限制为 <code>150次/每秒</code>， 时间不超过 <code>300秒</code>。</li><li><strong>MEMORY</strong> - 没有相关文档描述限制信息。</li></ul><p>与“EXC_GUARD”类似，它曾使用“位域”来传递信息，现在也使用“Exception SubType”和“Exception Message”。</p><pre tabindex=0><code>Exception Type: EXC_RESOURCE
Exception Subtype: CPU
Exception Message: (Limit 50%) Observed 85% over 180 secs
---
Exception Type: EXC_RESOURCE
Exception Subtype: WAKEUPS
Exception Message: (Limit 150/sec) Observed 206/sec over 300 secs
---
Exception Type: EXC_RESOURCE
Exception Subtype: MEMORY
Exception Message: Crossed High Water Mark
</code></pre><h4 id=00000020>00000020<a hidden class=anchor aria-hidden=true href=#00000020>#</a></h4><p>与“<strong>EXC_</strong>”异常不同，这个“异常类型”实际上不能告诉你任何信息。取而代之，你应该查看“异常代码”获取更多详情。</p><ul><li><code>0x8badf00d</code>（读作 <strong>ate bad food</strong>）- 表示由于 watchdog 出现超时而导致应用被操作系统终止。通常意味着应用程序花了太长时间启动、关闭或者响应系统事件。一个非常典型的情况是“在主线程上做同步网络请求”。</li><li><code>0xbaaaaaad</code>（读作 “plooookhy”）- 表示日志是整个系统的堆栈，而不是崩溃报告。</li><li><code>0xc00010ff</code>（读作 <strong>cool off（冷静）</strong>）- 表示应用程序被系统关闭以响应热事件。</li><li><code>0xbad22222</code> - 表示操作系统终止了一个VoIP程序，因为它过于频繁的执行恢复。</li><li><code>0xdead10cc</code>（读作 <strong>dead lock（死锁）</strong>）- 表示应用在后台运行时保持了系统资源。</li><li><code>0xdeadfa11</code>（读作 <strong>deadfall</strong>）- 表示应用被用户强制关闭了。强制关闭发生于用户先按下电源键直到“滑动来关机”出现然后按住主屏幕按钮。</li></ul><blockquote><p>这些“十六进制”代码实际上是<a href=https://en.wikipedia.org/wiki/Hexspeak>六音词</a> - 由我们开发者创建作为不容易忘记的魔法数字。</p></blockquote><h3 id=扩展阅读>扩展阅读<a hidden class=anchor aria-hidden=true href=#扩展阅读>#</a></h3><p>你可查看这篇文章 <a href=http://www.raywenderlich.com/23704/demystifying-ios-application-crash-logs>Demystifying iOS Application Crash Logs</a> 以了解iOS异常日志结构。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://coderx.wang/tags/ios-%E5%BC%82%E5%B8%B8/>iOS 异常</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://coderx.wang/>编程蚂蚁</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>